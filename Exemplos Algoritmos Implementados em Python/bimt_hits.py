# -*- coding: utf-8 -*-
"""bimt-hits.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uNR2aMGOQxC2dJVTP537f2h2Geo2hbGm
"""

import numpy as np

L = np.array([[0, 0, 1, 0, 1],[1, 0, 1, 0, 0],[0, 1, 0, 1, 0],[1, 0, 0, 0, 1],[0, 0, 1, 0, 0]])
n = L.shape[0]

hubs = np.ones(n)
auts = np.ones(n)

ERROR = 10000000
NORM = 1 # sum of abs

DEF_SIZE = 50

def center(s,size=DEF_SIZE):
  tam = (size - len(s))//2
  return " "*tam+s

def print_line(char="=",size=DEF_SIZE):
  print(char*size)

print_line()
print(center("L"))
print(L)
print_line("-")
print(f"n = {n}")
print_line("-")
print(center("hubs e auts"))
print(hubs,auts)

def hits_matrixes(L):
    LT = L.transpose()
    AUT = LT.dot(L)
    HUB = L.dot(LT)
    return AUT,HUB,LT

AUT,HUB,LT = hits_matrixes(L)

print_line()
print(center("AUT"))
print(AUT)
print(center("HUB"))
print(HUB)
print(center("LT"))
print(LT)



"""# HITS como o livro acha o resultado"""

# controlando a impressão de números

np.set_printoptions(precision=3)
np.set_printoptions(suppress=True)


# erro admitido
epsilon = np.ones(n)/ERROR

# no início os vetores são unitários
auts = np.ones(n)
hubs = np.ones(n)

print_line(size=80)
print(center("norma calculada ||1",80))

passo = 0
while True:
  passo += 1
  auts_old = auts # guarda para calcular o erro
  hubs_old = hubs
  auts = LT.dot(hubs) # conta básica
  hubs = L.dot(auts)

  norma = 0 # calcula normas || ||1 
  for i in auts:
    norma += abs(i)
  normh = 0
  for j in hubs:
    normh += abs(j)
  auts /= norma #max(auts)
  hubs /= normh #max(hubs)

  print(f"passo {passo:2d} {auts} {hubs}")  #verifica se chegou no erro admitido
  if  (((abs(hubs - hubs_old)) < epsilon).all()) and \
      (((abs(auts - auts_old)) < epsilon).all()):
    break

print_line("-",80)
print(center("resultado",size=80))
print(auts,hubs)

# mesmo programa que o anterior usando agora a norma do np

np.set_printoptions(precision=3)
np.set_printoptions(suppress=True)

epsilon = np.ones(n)/ERROR

auts = np.ones(n)
hubs = np.ones(n)

print_line(size=80)
print(center("norma nympy linalg",80))


while True:
  auts_old = auts
  hubs_old = hubs
  auts = LT.dot(hubs)
  hubs = L.dot(auts)

  norma = np.linalg.norm(auts,ord=NORM)
  normh = np.linalg.norm(hubs,ord=NORM)
  auts /= norma 
  hubs /= normh 

  print(f"passo {passo:2d} {auts} {hubs}")  #verifica se chegou no erro admitido
  if  (((abs(hubs - hubs_old)) < epsilon).all()) and \
      (((abs(auts - auts_old)) < epsilon).all()):
    break


print_line("-",80)
print(center("resultado",size=80))
print(auts,hubs)

def power(A,x):
  return A.dot(x.transpose())


# potencia com a norma linalg
def powerk(A,k,x):
  AK = A
  for i in range(k-1):
    AK = AK.dot(A)
  R = AK.dot(x.transpose())
  norma = np.linalg.norm(R,ord=NORM)
  return R/norma

# potencia com a norma calculada
def powerk2(A,k,x):
  AK = A
  for i in range(k-1):
    AK = AK.dot(A)
  R = AK.dot(x.transpose())
  soma = 0
  for i in R:
    soma += i
  return R/soma

import math
S = np.array([1, 1, 1, 1, 1])
S1 = S.copy()
for i in range(5):
  S = power(AUT,S.transpose())
  norma = 0
  for value in S:
    norma += value**2
  norma = math.sqrt(norma)
  #if i %10 == 0:
  print(S/norma)

print_line()
print(center("powerk"))
print(powerk(AUT,15,S1))
print(center("powerk2"))
print(powerk2(AUT,15,S1))