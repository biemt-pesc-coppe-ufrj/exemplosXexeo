# -*- coding: utf-8 -*-
"""bimt-booleano.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xfMbSkdnkCCvjvxb0mlVLC9NU0m2tBaB

# Programa bool0
Cria documentos e termos em memória
"""

import nltk
nltk.download('gutenberg')
docs=[0]*6  # Vetor de Documentos

# Escolhe 6 documentos entre os fornecidos
docs[0]=nltk.corpus.gutenberg.words('austen-sense.txt')
docs[1]=nltk.corpus.gutenberg.words('shakespeare-caesar.txt')
docs[2]=nltk.corpus.gutenberg.words('shakespeare-hamlet.txt')
docs[3]=nltk.corpus.gutenberg.words('shakespeare-macbeth.txt')
docs[4]=nltk.corpus.gutenberg.words('melville-moby_dick.txt')
docs[5]=nltk.corpus.gutenberg.words('carroll-alice.txt')

# Define os termos 
words = ["Hamlet" ,
         "Macbeth",
         "Caesar",
         "Antony",
         "Cleopatra",
         "John",
         "Ishmael",
         "Elinor",
         "Marianne",
         "Alice"
         ]
words.sort()


mtd = [0]*len(words) # Matriz Termo Documentos
for i in range(len(words)):
  mtd[i] = [0]*len(docs)

"""# Programa bool1

Cria uma Matriz Termo Documento usando propriedades do Python
"""

# Verifica se os termos estão presentes nos documentos
# e preenche a matriz termo documentos

for docn in range(len(docs)):
  for wordn in range(len(words)):
    if words[wordn] in docs[docn]:
      mtd[wordn][docn]=1

# imprime para verificação

print("    DOCS-> ","0 1 2 3 4 5")
for i in range(len(words)):
  print("%10s  "%words[i],end='')
  for j in range(len(docs)):
    print(mtd[i][j],end=' ')
  print()

"""# Cria lista invertida

Cria a lista invertida a partir da mtd
"""

# Lista invertida
lista_invertida={}
for wordn in range(len(words)):
  lista_invertida[words[wordn]]=[]
  for docn in range(len(docs)):
    if mtd[wordn][docn] == 1:
      lista_invertida[words[wordn]].append(docn)

print(lista_invertida)

"""# Manipula lista ordenada

Essas funções só fazem sentido como exemplo do algoritmo, porque o Python fornece coisas melhores.
"""

def pandq(p,q):
  ans = []
  while p and q:
    if p[0] == q[0]:
      ans.append(p[0])
      p = p[1:]
    elif p[0]<q[0]:
      p = p[1:]
    else:
      q = q[1:]
  return ans

def pnotq(p,q):
  ans = []
  while p and q:
    if p[0] == q[0]:
      p = p[1:]
      q = q[1:]
    elif p[0]<q[0]:
      ans.append(p[0])
      p = p[1:]
    else:
      q = q[1:]
  if p:
    ans.extend(p)
  return ans

def porq(p,q):
  ans = []
  while p and q:
    if p[0] == q[0]:
      ans.append(p[0])
      p = p[1:]
      q = q[1:]
    elif p[0]<q[0]:
      ans.append(p[0])
      p = p[1:]
    else:
      ans.append(q[0])
      q = q[1:]
  if p:
    ans.extend(p) 
  if q:
    ans.extend(q)
  return ans

"""# Testa as funções"""

# test
l_all = [x for x in range(10)]
l_odd = list(filter(lambda x : x%2 == 1,l_all))
l_even = list(filter(lambda x : x%2 == 0,l_all))
print(l_all,l_even,l_odd)
print(pandq(l_all,l_odd))
print(pandq(l_odd,l_all))
print(pandq(l_all,l_even))
print(pandq(l_even,l_odd))
print(porq(l_all,l_odd))
print(porq(l_all,l_even))
print(porq(l_even,l_odd))
print(pnotq(l_all,l_odd))
print(pnotq(l_all,l_even))
print(pnotq(l_even,l_odd))
print(pnotq(l_odd,l_even))
print(pnotq(l_even,l_all))

"""# Faz todos os "E"s da lista invertida"""

for i in lista_invertida:
  for j in lista_invertida:
    print(i,j,pandq(lista_invertida[i],lista_invertida[j]))

"""# Teste pnotq"""

for i in lista_invertida:
  for j in lista_invertida:
    print(i," e não ",j,pnotq(lista_invertida[i],lista_invertida[j]))

"""# Cria lista invertida "na mão"

Aqui uma forma de criar listas invertidas termo a termo do documento, porém só os termos que estamos interessados

É similar ao que se faz na prática
"""

lis_inver = {}

for docn in range(len(docs)): # tamanho da coleção de documentos
  for term in docs[docn]: # le o documento termo a termo
    if term in words:# se o termo deve ser indexado
      if docn not in lis_inver.get(term,[]): # e ainda não foi indexado
        lis_inver[term] = lis_inver.get(term,[])+[docn] #indexa

#mostra o resultado
keys = list(lis_inver.keys())
keys.sort()
for key in keys:
  print("%10s ->"%key,end=" ")
  print(lis_inver[key])

"""# Infix to PostFix

Usamos a notação infix para executar facilmente um expressão entregue na notação postfix. É mais fácil a transformação, nesse caso, que fazer o parser da string , criar a árvore e executar na ordem certa.

Essa função não verifica a sintaxe da expressão algébrica, logo não detecta erros como (A OU B) C E.

1. Scan the infix expression from left to right.
2. If the scanned character is an operand, output it.
3. Else,
3.1. If the precedence of the scanned operator is greater than the precedence of the operator in the stack(or the stack is empty or the stack contains a ‘(‘ ), push it.
…..3.2 Else, Pop all the operators from the stack which are greater than or equal to in precedence than that of the scanned operator. After doing that Push the scanned operator to the stack. (If you encounter parenthesis while popping then stop there and push the scanned operator in the stack.)
4. If the scanned character is an ‘(‘, push it to the stack.
5. If the scanned character is an ‘)’, pop the stack and and output it until a ‘(‘ is encountered, and discard both the parenthesis.
6. Repeat steps 2-6 until infix expression is scanned.
7. Print the output
8. Pop and output from the stack until it is not empty.

Esse algoritmo foi encontrado em https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/
"""

# essa tabele da prioridades ajuda a decidir
# se devemos ou não colocar a lista na saida quando 
# lemos um operador novo
prioridade = {"(" : 10 , ")" : 10 , "NÃO" : 9 ,
              "NOT" : 9 , "E" : 8 ,"AND" : 8, 
              "OU" : 7 , "OR" : 7 , "+" : 7 , 
              "." : 8 , "~" : 9, 
              "*" : 8 , "-" : 9}


def i2p(expr):
  pilha = []
  saida = []
  # conserta espaços faltando
  entrada = expr.replace("("," ( ").replace(")"," ) ").split()
  for token in entrada:
    pt = prioridade.get(token,0)
    if pt == 0: # if operando, output , operandos vão direto para a saída
      saida.append(token)
    elif token == "(": # abre parenteses vai direto para a pilha
      pilha.append(token)
    elif token == ")":
      while pilha and pilha[-1] != "(":
        saida.append(pilha.pop())
      pilha.pop()
    elif not pilha: # if stack empty
      pilha.append(token)
    elif pt>prioridade.get(pilha[-1],0):
        pilha.append(token)  
    elif "(" in pilha[-1]: # if top stack is ()
      pilha.append(token)
    else:
      while pilha and prioridade[pilha[-1]] >= pt and pilha[-1] != "(":
        saida.append(pilha.pop())
      pilha.append(token)
  while pilha :
    saida.append(pilha.pop())
  return(saida)

TESTE = "(A  NOT B) E C  NOT (D OU NOT(F))"
TESTE2 = "A NOT B OU C"
TESTE3 = "A E B OU C"
print(i2p(TESTE))
print(i2p(TESTE2))
print(i2p(TESTE3))

"""# faz a consulta expr na coleção docs

Usa os documentos de forma direta com o "in" do Python
"""

def processa(expr,docs):
  consulta = i2p(expr)
  pilha = []
  ops = prioridade.keys()
  for tk in consulta:
    if tk not in ops:
      lista = []
      for docn in range(len(docs)):
        if tk in docs[docn]:
         lista.append(docn)
      pilha.append(lista)
    if tk in ["E","*",".","AND"]:
      pilha.append(pandq(pilha.pop(),pilha.pop()))
    if tk in ["OU","+","OR"] :
      pilha.append(porq(pilha.pop(),pilha.pop()))
    if tk in ["NOT","~","-","NÃO"]:
      buf = pilha.pop()
      pilha.append(pnotq(pilha.pop(),buf))
  return(pilha.pop())
      
print(processa("Caesar E Antony OU Alice",docs))
print(processa("Caesar - Antony + Alice * (cat + though)",docs))

"""# Aqui usamos conjuntos e operações de conjuntos em Python"""

def processa_booleano(expr,docs):
  consulta = i2p(expr)
  pilha = []
  ops = prioridade.keys()
  for tk in consulta:
    if tk not in ops:
      found = set()
      for docn in range(len(docs)):
        if tk in docs[docn]: 
          found.add(docn)
      pilha.append(found)
    if tk in ["E","*",".","AND"]:
      pilha.append(pilha.pop().intersection(pilha.pop()))
    if tk in ["OU","+","OR"]:
      pilha.append(pilha.pop().union(pilha.pop()))
    if tk in ["NOT","~","-","NÃO"]:
      buf = pilha.pop()
      pilha.append(pilha.pop().difference(buf))
  return(pilha.pop())

for w in words:
  print(" {:>10} - {}".format(w,processa_booleano(w,docs)))

queries = ["Hamlet AND Caesar",
           "Hamlet NOT Caesar",
           "Elinor OR Alice",
           "Elinor OR Alice AND Hamlet",
           "(Elinor OR Alice) AND Hamlet",
           "Elinor OR (Alice NOT Caesar) AND Caesar",
           "Antony OR Alice OR Caesar AND John",
           "Rome",
           "London",
           "Rome OR London"
           ]

for q in queries:
  print(i2p(q))
  print(" {:>20} - {}".format(q,processa_booleano(q,docs)))

"""# Processa com o índice

Aqui partimos da lista invertida, não dos documentos
 e usamos nossos operadores de listas
pandq, porq e pnotq
"""

def processa_booleano_lista(expr,lista_invertida):
  consulta = i2p(expr)
  pilha = []
  ops = prioridade.keys()
  for tk in consulta:
    if tk not in ops:
      pilha.append(lista_invertida[tk])
    if tk in ["E","*",".","AND"]:
      pilha.append(pandq(pilha.pop(),pilha.pop()))
    if tk in ["OU","+","OR"]:
      pilha.append(porq(pilha.pop(),pilha.pop()))
    if tk in ["NOT","~","-","NÃO"]:
      buf = pilha.pop()
      pilha.append(pnotq(pilha.pop(),buf))
  return(pilha.pop())

for w in words:
  print(" {:>10} - {}".format(w,processa_booleano_lista(w,lis_inver)))

queries = ["Hamlet AND Caesar",
           "Hamlet NOT Caesar",
           "Elinor OR Alice",
           "Elinor OR Alice AND Hamlet",
           "(Elinor OR Alice) AND Hamlet",
           "Elinor OR (Alice NOT Caesar) AND Caesar",
           "Antony OR Alice OR Caesar AND John",
           ]

for q in queries:
  print(i2p(q))
  print(" {:>20} - {}".format(q,processa_booleano_lista(q,lis_inver)))